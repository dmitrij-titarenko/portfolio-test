const container = document.getElementById('webgl-overlay');
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
        });
        
        // Set the renderer size to the window size initially
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 1;

        const video = document.querySelector('.background-video');
        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.format = THREE.RGBFormat;

        const uniforms = {
            videoTexture: { value: videoTexture },
            mouse: { value: { x: 0.5, y: 0.5 } },
            time: { value: 0 },
        };

        const vertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
        `;

        const fragmentShader = `
        uniform sampler2D videoTexture;
        uniform vec2 mouse;
        uniform float time;
        varying vec2 vUv;

        // Simplex noise function (advanced)
vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
    return mod289(((x*34.0)+1.0)*x);
}

float simplexNoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                       -0.577350269189626,  // -1.0 + 2.0 * C.x
                        0.024390243902439); // 1.0 / 41.0
                // First corner
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);

                // Other corners
                vec2 i1;
                //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
                //i1.y = 1.0 - i1.x;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                // x0 = x0 - 0.0 + 0.0 * C.xx ;
                // x1 = x0 - i1 + 1.0 * C.xx ;
                // x2 = x0 - 1.0 + 2.0 * C.xx ;
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;

                // Permutations
                i = mod289(i); // Avoid truncation effects in permutation
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));

                vec3 m = max(0.5 - vec3(
                dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)
                ), 0.0);
                m = m*m ;
                m = m*m ;

                // Gradients: 41 points uniformly over a unit circle.
                // The ring size 41 was chosen because it is coprime with 289 (see
                // permutation in vec3 permute(vec3 x)). Therefore, the "random" numbers
                // generated by permute will be uniformly distributed over the unit circle.
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;

                // Normalise gradients implicitly by scaling m
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

                // Compute final noise value at P
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            void main() {
                vec2 uv = vUv;

                float distToMouse = distance(uv, mouse);
                float mouseEffect = smoothstep(0.15, 0.0, distToMouse);
            vec2 turbulence = vec2(
                    simplexNoise(uv * 3.0 + time * 0.1),
                    simplexNoise(uv * 1.5 - time * 0.1)
            ) * 0.25;

            turbulence += vec2(
                simplexNoise(uv * 1.5 + time * 0.05),
                simplexNoise(uv * 3.0 - time * 0.05)
            ) * 0.2;

            uv += turbulence * (0.1 - mouseEffect);

            vec4 color = texture2D(videoTexture, uv);

            vec3 black = vec3(0.0, 0.0, 0.0);
            vec3 darkBlue = vec3(0.0, 0.1, 0.1);
            vec3 blendedColor = mix(black, darkBlue, mouseEffect);

            color.rgb = color.rgb * (1.0 - mouseEffect) + blendedColor * mouseEffect;

            gl_FragColor = color;
        }
        `;

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms,
        });

        const aspect = window.innerWidth / window.innerHeight;
        const geometry = new THREE.PlaneGeometry(aspect * 2, aspect * 2);
        const plane = new THREE.Mesh(geometry, material);
        scene.add(plane);

        let targetMouseX = 0;
        let targetMouseY = 0;
        let currentMouseX = 0;
        let currentMouseY = 0;
        const smoothness = 0.05;

        window.addEventListener('load', () => {
            targetMouseX = 0.5;  // Center of the screen
            targetMouseY = 0.5;
        });

        window.addEventListener('mousemove', (event) => {
            targetMouseX = event.clientX / window.innerWidth;
            targetMouseY = 1 - (event.clientY / window.innerHeight);
        });

        function updateMousePosition() {
            currentMouseX += (targetMouseX - currentMouseX) * smoothness;
            currentMouseY += (targetMouseY - currentMouseY) * smoothness;
            uniforms.mouse.value.x = currentMouseX;
            uniforms.mouse.value.y = currentMouseY;
        }

        // Ensure the video is updating continuously
        videoTexture.needsUpdate = true;

        // Event listener to ensure the video plays continuously
        video.addEventListener('play', () => {
            video.play();
        });

        // Handle window resizing
        window.addEventListener('resize', () => {
            // Resize the renderer to the window's current dimensions
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Adjust the aspect ratio of the camera
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            // Adjust the geometry of the plane according to the new aspect ratio
            const aspect = window.innerWidth / window.innerHeight;
            plane.geometry.dispose();
            plane.geometry = new THREE.PlaneGeometry(2, 2);
        });

        function animate() {
            requestAnimationFrame(animate);

            // Continuously ensure the video texture is updated
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                videoTexture.needsUpdate = true;
            }

            updateMousePosition();
            uniforms.time.value += 0.05;
            
            renderer.render(scene, camera);
        }

        animate();